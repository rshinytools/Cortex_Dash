# ABOUTME: Production-specific Makefile commands for managing deployments
# ABOUTME: Includes commands for updates, backups, and feature additions

# Include this in your main Makefile with: include Makefile.production

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PRODUCTION UPDATE COMMANDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## Regular Updates (Zero Downtime)
update-backend: ## Update only backend with rolling restart (zero downtime)
	@echo "$(YELLOW)ğŸ“¦ Updating backend service...$(NC)"
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml build backend
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml up -d --no-deps --scale backend=2 backend
	@sleep 10
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml up -d --no-deps --scale backend=1 backend
	@echo "$(GREEN)âœ… Backend updated successfully$(NC)"

update-frontend: ## Update only frontend with rolling restart (zero downtime)
	@echo "$(YELLOW)ğŸ“¦ Updating frontend service...$(NC)"
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml build frontend
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml up -d --no-deps --scale frontend=2 frontend
	@sleep 10
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml up -d --no-deps --scale frontend=1 frontend
	@echo "$(GREEN)âœ… Frontend updated successfully$(NC)"

update-prod: ## Complete production update with zero downtime
	@echo "$(BLUE)ğŸš€ Starting zero-downtime production update...$(NC)"
	@make update-backend
	@make update-frontend
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml up -d --no-deps nginx redis
	@make run-migrations
	@echo "$(GREEN)âœ… Production update complete!$(NC)"

quick-fix-backend: ## Quick backend code fix without rebuild (for hotfixes)
	@echo "$(YELLOW)ğŸ”§ Applying quick backend fix...$(NC)"
	@docker cp backend/. $$(docker ps -qf "name=backend" | head -1):/app/backend/
	@docker exec $$(docker ps -qf "name=backend" | head -1) supervisorctl restart all
	@echo "$(GREEN)âœ… Backend fix applied$(NC)"

quick-fix-frontend: ## Quick frontend fix without rebuild
	@echo "$(YELLOW)ğŸ”§ Applying quick frontend fix...$(NC)"
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml restart frontend
	@echo "$(GREEN)âœ… Frontend fix applied$(NC)"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FEATURE ADDITION COMMANDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

add-widget: ## Add a new widget to running system (usage: make add-widget WIDGET=metrics_card)
	@echo "$(YELLOW)â• Adding widget: $(WIDGET)$(NC)"
	@docker exec $$(docker ps -qf "name=backend" | head -1) python -m app.db.seed_$(WIDGET)_widget || echo "Widget seeding completed"
	@echo "$(GREEN)âœ… Widget added successfully$(NC)"

add-migration: ## Create and run a new database migration
	@echo "$(YELLOW)ğŸ—„ï¸ Creating new migration...$(NC)"
	@docker exec -it $$(docker ps -qf "name=backend" | head -1) alembic revision --autogenerate -m "$(MSG)"
	@make run-migrations
	@echo "$(GREEN)âœ… Migration created and applied$(NC)"

run-migrations: ## Run pending database migrations
	@echo "$(YELLOW)ğŸ—„ï¸ Running database migrations...$(NC)"
	@docker exec $$(docker ps -qf "name=backend" | head -1) alembic upgrade head
	@echo "$(GREEN)âœ… Migrations complete$(NC)"

seed-widgets: ## Seed all widgets into running system
	@echo "$(YELLOW)ğŸŒ± Seeding widgets...$(NC)"
	@docker exec $$(docker ps -qf "name=backend" | head -1) python scripts/seed_widgets.py
	@docker exec $$(docker ps -qf "name=backend" | head -1) python scripts/seed_data_quality_widgets.py
	@docker exec $$(docker ps -qf "name=backend" | head -1) python scripts/seed_more_widgets.py
	@docker exec $$(docker ps -qf "name=backend" | head -1) python -m app.db.seed_metrics_card_widget
	@echo "$(GREEN)âœ… All widgets seeded$(NC)"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BACKUP AND RESTORE COMMANDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

backup-db: ## Create database backup
	@echo "$(YELLOW)ğŸ’¾ Creating database backup...$(NC)"
	@mkdir -p backups/db
	@docker exec $$(docker ps -qf "name=db") pg_dump -U postgres app > backups/db/backup_$$(date +%Y%m%d_%H%M%S).sql
	@echo "$(GREEN)âœ… Database backed up to backups/db/$(NC)"

backup-files: ## Backup uploaded files and data
	@echo "$(YELLOW)ğŸ’¾ Creating files backup...$(NC)"
	@mkdir -p backups/files
	@docker run --rm -v $$(docker volume ls -qf "name=app_data"):/data -v $$(pwd)/backups/files:/backup alpine \
		tar czf /backup/files_backup_$$(date +%Y%m%d_%H%M%S).tar.gz -C /data .
	@echo "$(GREEN)âœ… Files backed up to backups/files/$(NC)"

backup-all: ## Complete backup (database + files)
	@echo "$(BLUE)ğŸ’¾ Creating complete backup...$(NC)"
	@make backup-db
	@make backup-files
	@echo "$(GREEN)âœ… Complete backup finished$(NC)"

restore-db: ## Restore database from backup (usage: make restore-db FILE=backup.sql)
	@echo "$(RED)âš ï¸  WARNING: This will overwrite the current database!$(NC)"
	@echo "Press Ctrl+C to cancel, or wait 5 seconds to continue..."
	@sleep 5
	@echo "$(YELLOW)ğŸ“¥ Restoring database from $(FILE)...$(NC)"
	@docker exec -i $$(docker ps -qf "name=db") psql -U postgres app < $(FILE)
	@echo "$(GREEN)âœ… Database restored$(NC)"

restore-files: ## Restore files from backup (usage: make restore-files FILE=files_backup.tar.gz)
	@echo "$(RED)âš ï¸  WARNING: This will overwrite current files!$(NC)"
	@echo "Press Ctrl+C to cancel, or wait 5 seconds to continue..."
	@sleep 5
	@echo "$(YELLOW)ğŸ“¥ Restoring files from $(FILE)...$(NC)"
	@docker run --rm -v $$(docker volume ls -qf "name=app_data"):/data -v $$(pwd)/backups/files:/backup alpine \
		tar xzf /backup/$(FILE) -C /data
	@echo "$(GREEN)âœ… Files restored$(NC)"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAINTENANCE COMMANDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

health-check: ## Check health of all services
	@echo "$(YELLOW)ğŸ¥ Checking service health...$(NC)"
	@echo "Backend: $$(curl -s http://localhost/api/health | jq -r .status || echo "âŒ DOWN")"
	@echo "Frontend: $$(curl -s http://localhost:3000/api/health | jq -r .status || echo "âŒ DOWN")"
	@echo "Database: $$(docker exec $$(docker ps -qf "name=db") pg_isready -U postgres || echo "âŒ DOWN")"
	@echo "Redis: $$(docker exec $$(docker ps -qf "name=redis") redis-cli ping || echo "âŒ DOWN")"

prod-logs: ## Tail production logs
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml logs -f --tail=100

prod-logs-backend: ## Tail backend logs only
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml logs -f --tail=100 backend

prod-logs-frontend: ## Tail frontend logs only
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml logs -f --tail=100 frontend

prod-stats: ## Show resource usage statistics
	@echo "$(YELLOW)ğŸ“Š Resource Usage:$(NC)"
	@docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}\t{{.BlockIO}}"

scale-backend: ## Scale backend service (usage: make scale-backend REPLICAS=3)
	@echo "$(YELLOW)âš–ï¸ Scaling backend to $(REPLICAS) replicas...$(NC)"
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml up -d --scale backend=$(REPLICAS) backend
	@echo "$(GREEN)âœ… Backend scaled to $(REPLICAS) replicas$(NC)"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEPLOYMENT WORKFLOW COMMANDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

deploy-patch: ## Deploy a patch update (bug fixes only)
	@echo "$(BLUE)ğŸ©¹ Deploying patch update...$(NC)"
	@make backup-db
	@make update-prod
	@make health-check
	@echo "$(GREEN)âœ… Patch deployed successfully$(NC)"

deploy-minor: ## Deploy minor update (new features, backward compatible)
	@echo "$(BLUE)ğŸ“¦ Deploying minor update...$(NC)"
	@make backup-all
	@make update-prod
	@make seed-widgets
	@make health-check
	@echo "$(GREEN)âœ… Minor update deployed successfully$(NC)"

deploy-major: ## Deploy major update (breaking changes, full restart)
	@echo "$(RED)ğŸš€ Deploying major update...$(NC)"
	@echo "$(RED)âš ï¸  This will cause downtime! Press Ctrl+C to cancel...$(NC)"
	@sleep 5
	@make backup-all
	@make down-prod
	@make up-prod
	@make run-migrations
	@make seed-widgets
	@make health-check
	@echo "$(GREEN)âœ… Major update deployed successfully$(NC)"

rollback: ## Rollback to previous version using git
	@echo "$(RED)âª Rolling back to previous version...$(NC)"
	@git checkout HEAD~1
	@make deploy-patch
	@echo "$(GREEN)âœ… Rollback complete$(NC)"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SCHEDULED MAINTENANCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

schedule-backup: ## Create a cron job for automated backups
	@echo "$(YELLOW)â° Setting up automated backups...$(NC)"
	@echo "0 2 * * * cd $(shell pwd) && make backup-all" | crontab -
	@echo "$(GREEN)âœ… Daily backups scheduled at 2 AM$(NC)"

cleanup-old-backups: ## Remove backups older than 30 days
	@echo "$(YELLOW)ğŸ§¹ Cleaning old backups...$(NC)"
	@find backups -type f -mtime +30 -delete
	@echo "$(GREEN)âœ… Old backups removed$(NC)"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EMERGENCY COMMANDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

emergency-stop: ## Emergency stop all services
	@echo "$(RED)ğŸš¨ EMERGENCY STOP$(NC)"
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml stop

emergency-restart: ## Emergency restart (use when system is unresponsive)
	@echo "$(RED)ğŸš¨ EMERGENCY RESTART$(NC)"
	@$(DOCKER_COMPOSE) -f docker-compose.prod.yml restart

fix-permissions: ## Fix file permissions issues
	@echo "$(YELLOW)ğŸ”§ Fixing permissions...$(NC)"
	@docker exec $$(docker ps -qf "name=backend") chown -R app:app /app/data
	@echo "$(GREEN)âœ… Permissions fixed$(NC)"

clear-cache: ## Clear all caches
	@echo "$(YELLOW)ğŸ§¹ Clearing caches...$(NC)"
	@docker exec $$(docker ps -qf "name=redis") redis-cli FLUSHALL
	@echo "$(GREEN)âœ… Caches cleared$(NC)"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MONITORING AND DEBUGGING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

monitor: ## Open monitoring dashboard
	@echo "$(YELLOW)ğŸ“Š Opening monitoring dashboard...$(NC)"
	@echo "Backend logs: make prod-logs-backend"
	@echo "Frontend logs: make prod-logs-frontend"
	@echo "Resource usage: make prod-stats"
	@echo "Health status: make health-check"

debug-backend: ## Connect to backend for debugging
	@docker exec -it $$(docker ps -qf "name=backend" | head -1) bash

debug-db: ## Connect to database for debugging
	@docker exec -it $$(docker ps -qf "name=db") psql -U postgres app

analyze-db: ## Analyze database performance
	@echo "$(YELLOW)ğŸ” Analyzing database...$(NC)"
	@docker exec $$(docker ps -qf "name=db") psql -U postgres app -c "SELECT pg_size_pretty(pg_database_size('app'));"
	@docker exec $$(docker ps -qf "name=db") psql -U postgres app -c "SELECT tablename, pg_size_pretty(pg_total_relation_size(tablename::regclass)) as size FROM pg_tables WHERE schemaname = 'public' ORDER BY pg_total_relation_size(tablename::regclass) DESC LIMIT 10;"