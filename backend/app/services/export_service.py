# ABOUTME: Export service for generating dashboard exports in PDF, PowerPoint, and Excel formats
# ABOUTME: Handles dashboard rendering, file generation, and export management

import io
import os
import tempfile
import uuid
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment
from openpyxl.utils.dataframe import dataframe_to_rows
from pptx import Presentation
from pptx.util import Inches, Pt
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, PageBreak
from reportlab.platypus.flowables import KeepTogether
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.dashboard import DashboardTemplate
from app.models.widget import WidgetDefinition
from app.models.user import User
from app.core.config import settings
from app.services.widget_service import WidgetService
from app.crud.dashboard import get_dashboard_async as get_dashboard
from app.crud.widget import get_widgets_by_dashboard


class ExportService:
    def __init__(self, db: AsyncSession):
        self.db = db
        self.widget_service = WidgetService(db)
        self.export_dir = Path(settings.DATA_DIR) / "exports"
        self.export_dir.mkdir(exist_ok=True)
    
    async def export_dashboard(
        self,
        dashboard_id: str,
        format: str,
        user: User,
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Export dashboard in specified format"""
        dashboard = await get_dashboard(self.db, dashboard_id)
        if not dashboard:
            raise ValueError(f"Dashboard {dashboard_id} not found")
        
        widgets = await get_widgets_by_dashboard(self.db, dashboard_id)
        
        export_id = str(uuid.uuid4())
        timestamp = datetime.utcnow()
        
        if format == "pdf":
            file_path = await self._export_to_pdf(dashboard, widgets, user, timestamp, export_id)
        elif format == "pptx":
            file_path = await self._export_to_pptx(dashboard, widgets, user, timestamp, export_id)
        elif format == "xlsx":
            file_path = await self._export_to_xlsx(dashboard, widgets, user, timestamp, export_id)
        else:
            raise ValueError(f"Unsupported export format: {format}")
        
        return {
            "export_id": export_id,
            "dashboard_id": dashboard_id,
            "format": format,
            "file_path": str(file_path),
            "file_size": file_path.stat().st_size,
            "created_at": timestamp,
            "created_by": user.email
        }
    
    async def _export_to_pdf(
        self,
        dashboard: DashboardTemplate,
        widgets: List[WidgetDefinition],
        user: User,
        timestamp: datetime,
        export_id: str
    ) -> Path:
        """Export dashboard to PDF"""
        file_path = self.export_dir / f"{export_id}.pdf"
        
        doc = SimpleDocTemplate(
            str(file_path),
            pagesize=letter,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=18,
        )
        
        story = []
        styles = getSampleStyleSheet()
        
        # Title
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#1e40af'),
            spaceAfter=30,
            alignment=1  # Center alignment
        )
        story.append(Paragraph(dashboard.name, title_style))
        
        # Metadata
        meta_style = ParagraphStyle(
            'Metadata',
            parent=styles['Normal'],
            fontSize=10,
            textColor=colors.HexColor('#6b7280'),
            spaceAfter=20
        )
        meta_text = f"Generated on: {timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}<br/>"
        meta_text += f"Generated by: {user.email}<br/>"
        if dashboard.description:
            meta_text += f"Description: {dashboard.description}"
        story.append(Paragraph(meta_text, meta_style))
        story.append(Spacer(1, 0.5*inch))
        
        # Process each widget
        for widget in widgets:
            # Widget title
            widget_title = Paragraph(widget.title, styles['Heading2'])
            story.append(widget_title)
            
            # Get widget data
            try:
                widget_data = await self.widget_service.get_widget_data(widget.id, user)
                
                if widget.type == "metric":
                    # Render metric as a table
                    metric_data = [
                        ["Metric", "Value"],
                        [widget.title, str(widget_data.get("value", "N/A"))]
                    ]
                    if widget_data.get("trend"):
                        metric_data.append(["Trend", f"{widget_data['trend']['value']}%"])
                    
                    t = Table(metric_data, colWidths=[3*inch, 2*inch])
                    t.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, 0), 14),
                        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                        ('GRID', (0, 0), (-1, -1), 1, colors.black)
                    ]))
                    story.append(t)
                
                elif widget.type in ["line", "bar", "pie", "scatter"]:
                    # For charts, we'll add a placeholder or use the widget's image export
                    story.append(Paragraph(f"[{widget.type.upper()} CHART]", styles['Normal']))
                    if widget_data.get("data"):
                        # Add a simple data table
                        df = pd.DataFrame(widget_data["data"])
                        if not df.empty and len(df) <= 10:  # Limit rows for PDF
                            table_data = [df.columns.tolist()] + df.values.tolist()
                            t = Table(table_data)
                            t.setStyle(TableStyle([
                                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                                ('FONTSIZE', (0, 0), (-1, -1), 10),
                                ('GRID', (0, 0), (-1, -1), 1, colors.black)
                            ]))
                            story.append(t)
                
                elif widget.type == "table":
                    # Render table data
                    if widget_data.get("data"):
                        df = pd.DataFrame(widget_data["data"])
                        if not df.empty:
                            # Limit to first 20 rows for PDF
                            df_limited = df.head(20)
                            table_data = [df_limited.columns.tolist()] + df_limited.values.tolist()
                            
                            t = Table(table_data)
                            t.setStyle(TableStyle([
                                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                                ('FONTSIZE', (0, 0), (-1, -1), 8),
                                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])
                            ]))
                            story.append(t)
                            
                            if len(df) > 20:
                                story.append(Paragraph(f"... and {len(df) - 20} more rows", styles['Italic']))
                
            except Exception as e:
                story.append(Paragraph(f"Error loading widget data: {str(e)}", styles['Normal']))
            
            story.append(Spacer(1, 0.3*inch))
        
        # Build PDF
        doc.build(story)
        return file_path
    
    async def _export_to_pptx(
        self,
        dashboard: DashboardTemplate,
        widgets: List[WidgetDefinition],
        user: User,
        timestamp: datetime,
        export_id: str
    ) -> Path:
        """Export dashboard to PowerPoint"""
        file_path = self.export_dir / f"{export_id}.pptx"
        
        prs = Presentation()
        
        # Title slide
        title_slide_layout = prs.slide_layouts[0]
        slide = prs.slides.add_slide(title_slide_layout)
        title = slide.shapes.title
        subtitle = slide.placeholders[1]
        
        title.text = dashboard.name
        subtitle.text = f"Generated on: {timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}\nGenerated by: {user.email}"
        
        # Add slides for each widget
        for widget in widgets:
            # Add a slide with title and content layout
            slide_layout = prs.slide_layouts[5]  # Title and Content
            slide = prs.slides.add_slide(slide_layout)
            
            title = slide.shapes.title
            title.text = widget.title
            
            try:
                widget_data = await self.widget_service.get_widget_data(widget.id, user)
                
                # Add content based on widget type
                left = Inches(0.5)
                top = Inches(2)
                width = Inches(9)
                height = Inches(4.5)
                
                if widget.type == "metric":
                    # Add metric value as text
                    txBox = slide.shapes.add_textbox(left, top, width, height)
                    tf = txBox.text_frame
                    tf.text = f"Value: {widget_data.get('value', 'N/A')}"
                    
                    if widget_data.get("trend"):
                        p = tf.add_paragraph()
                        p.text = f"Trend: {widget_data['trend']['value']}%"
                        p.font.size = Pt(18)
                
                elif widget.type == "table" and widget_data.get("data"):
                    # Add table
                    df = pd.DataFrame(widget_data["data"])
                    if not df.empty:
                        rows, cols = min(len(df) + 1, 10), min(len(df.columns), 5)  # Limit size
                        
                        table = slide.shapes.add_table(rows, cols, left, top, width, height).table
                        
                        # Add headers
                        for i, col in enumerate(df.columns[:cols]):
                            table.cell(0, i).text = str(col)
                        
                        # Add data
                        for i in range(min(len(df), rows - 1)):
                            for j in range(cols):
                                table.cell(i + 1, j).text = str(df.iloc[i, j])
                
                else:
                    # For other types, add a placeholder
                    txBox = slide.shapes.add_textbox(left, top, width, height)
                    tf = txBox.text_frame
                    tf.text = f"[{widget.type.upper()} visualization]"
                    
                    if widget_data.get("data"):
                        p = tf.add_paragraph()
                        p.text = f"Data points: {len(widget_data['data'])}"
                
            except Exception as e:
                txBox = slide.shapes.add_textbox(left, top, width, height)
                tf = txBox.text_frame
                tf.text = f"Error loading widget data: {str(e)}"
        
        # Save presentation
        prs.save(str(file_path))
        return file_path
    
    async def _export_to_xlsx(
        self,
        dashboard: DashboardTemplate,
        widgets: List[WidgetDefinition],
        user: User,
        timestamp: datetime,
        export_id: str
    ) -> Path:
        """Export dashboard to Excel with multiple sheets"""
        file_path = self.export_dir / f"{export_id}.xlsx"
        
        wb = Workbook()
        
        # Dashboard info sheet
        ws = wb.active
        ws.title = "Dashboard Info"
        
        # Header style
        header_font = Font(bold=True, size=14, color="FFFFFF")
        header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
        header_alignment = Alignment(horizontal="center", vertical="center")
        
        # Add dashboard info
        ws["A1"] = "Dashboard Export"
        ws["A1"].font = Font(bold=True, size=16)
        ws.merge_cells("A1:D1")
        
        info_data = [
            ["Field", "Value"],
            ["Dashboard Name", dashboard.name],
            ["Description", dashboard.description or "N/A"],
            ["Generated On", timestamp.strftime("%Y-%m-%d %H:%M:%S UTC")],
            ["Generated By", user.email],
            ["Total Widgets", len(widgets)]
        ]
        
        for row_idx, row_data in enumerate(info_data, start=3):
            for col_idx, value in enumerate(row_data, start=1):
                cell = ws.cell(row=row_idx, column=col_idx, value=value)
                if row_idx == 3:  # Header row
                    cell.font = header_font
                    cell.fill = header_fill
                    cell.alignment = header_alignment
        
        # Auto-adjust column widths
        for column in ws.columns:
            max_length = 0
            column = [cell for cell in column]
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = (max_length + 2)
            ws.column_dimensions[column[0].column_letter].width = adjusted_width
        
        # Add a sheet for each widget with data
        for widget in widgets:
            try:
                widget_data = await self.widget_service.get_widget_data(widget.id, user)
                
                if widget_data.get("data"):
                    # Create sheet for widget
                    sheet_name = widget.title[:31]  # Excel sheet name limit
                    ws = wb.create_sheet(title=sheet_name)
                    
                    # Add widget info
                    ws["A1"] = f"Widget: {widget.title}"
                    ws["A1"].font = Font(bold=True, size=14)
                    ws.merge_cells("A1:D1")
                    
                    ws["A2"] = f"Type: {widget.type}"
                    ws["A3"] = f"Description: {widget.description or 'N/A'}"
                    
                    # Add data
                    if widget.type == "metric":
                        ws["A5"] = "Metric"
                        ws["B5"] = "Value"
                        ws["A5"].font = header_font
                        ws["A5"].fill = header_fill
                        ws["B5"].font = header_font
                        ws["B5"].fill = header_fill
                        
                        ws["A6"] = widget.title
                        ws["B6"] = widget_data.get("value", "N/A")
                        
                        if widget_data.get("trend"):
                            ws["A7"] = "Trend"
                            ws["B7"] = f"{widget_data['trend']['value']}%"
                    
                    else:
                        # Convert data to DataFrame and write to sheet
                        df = pd.DataFrame(widget_data["data"])
                        if not df.empty:
                            # Write headers
                            for col_idx, col_name in enumerate(df.columns, start=1):
                                cell = ws.cell(row=5, column=col_idx, value=col_name)
                                cell.font = header_font
                                cell.fill = header_fill
                                cell.alignment = header_alignment
                            
                            # Write data
                            for row_idx, row in enumerate(dataframe_to_rows(df, index=False, header=False), start=6):
                                for col_idx, value in enumerate(row, start=1):
                                    ws.cell(row=row_idx, column=col_idx, value=value)
                            
                            # Auto-adjust column widths
                            for column in ws.columns:
                                max_length = 0
                                column = [cell for cell in column]
                                for cell in column:
                                    try:
                                        if len(str(cell.value)) > max_length:
                                            max_length = len(str(cell.value))
                                    except:
                                        pass
                                adjusted_width = min(max_length + 2, 50)
                                ws.column_dimensions[column[0].column_letter].width = adjusted_width
                
            except Exception as e:
                # Create error sheet for widget
                sheet_name = f"{widget.title[:28]}..."[:31]
                ws = wb.create_sheet(title=sheet_name)
                ws["A1"] = f"Error loading widget: {widget.title}"
                ws["A2"] = f"Error: {str(e)}"
        
        # Save workbook
        wb.save(str(file_path))
        return file_path
    
    def get_export_path(self, export_id: str) -> Optional[Path]:
        """Get the path to an export file"""
        for ext in [".pdf", ".pptx", ".xlsx"]:
            file_path = self.export_dir / f"{export_id}{ext}"
            if file_path.exists():
                return file_path
        return None
    
    def delete_export(self, export_id: str) -> bool:
        """Delete an export file"""
        file_path = self.get_export_path(export_id)
        if file_path and file_path.exists():
            file_path.unlink()
            return True
        return False